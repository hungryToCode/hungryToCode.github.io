<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[常见排序算法]]></title>
    <url>%2F2019%2F01%2F13%2F%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[冒泡排序概述最简单的一种排序算法。先从数组中找到最大值(或最小值)并放到数组最左端(或最右端)，然后在剩下的数字中找到次大值(或次小值)，以此类推，直到数组有序排列。 时间复杂度O(n^2) 算法实现12345678910111213141516// 冒泡排序void BubbleSort(int arr[], int length)&#123; for (int i = 0; i &lt; length; i++) &#123; for (int j = 0; j &lt; length - i - 1; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; int temp; temp = arr[j + 1]; arr[j + 1] = arr[j]; arr[j] = temp; &#125; &#125; &#125; 选择排序###概述 假设长度为n的数组arr，先从n个数字中找到最小值min1，如果min1的位置不在数组的最左端，则交换这两个数字。接着在n-1个数中找到最小值min2，如果min2不在数组的第二个数，则同理交换，依次类推，直到数组arr为有序数列。 时间复杂度O(n^2) 算法实现1234567891011121314151617181920212223// 选择排序void SelectionSort(int arr[], int length)&#123; for (int i = 0; i &lt; length; i++) &#123; int index = i; for (int j = i+1; j &lt; length; j++) &#123; if (arr[j] &lt; arr[index]) &#123; index = j; &#125; &#125; if (index == i) continue; else &#123; int temp; temp = arr[index]; arr[index] = arr[i]; arr[i] = temp; &#125; &#125; 插入排序概述 插入排序的基本思想就是将无序序列插入到有序序列中。例如要将数组arr=[4,2,8,0,5,1]排序，可以将4看做是一个有序序列(图中用蓝色标出)，将[2,8,0,5,1]看做一个无序序列。无序序列中2比4小，于是将2插入到4的左边，此时有序序列变成了[2,4]，无序序列变成了[8,0,5,1]。无序序列中8比4大，于是将8插入到4的右边，有序序列变成了[2,4,8],无序序列变成了[0,5,1]。以此类推，最终数组按照从小到大排序。 时间复杂度O(n^2) 算法实现1234567891011121314151617// 插入排序void InsertSort(int arr[], int length)&#123; for (int i = 1; i &lt; length; i++) &#123; int j; if (arr[i] &lt; arr[i - 1]) &#123; int temp = arr[i]; for (j = i - 1; j &gt;= 0 &amp;&amp; temp &lt; arr[j]; j--) &#123; arr[j + 1] = arr[j]; &#125; //j--之后不满足 j&gt;= 0 &amp;&amp; temp &lt; arr[j]，所以得+1补偿回来，在赋值 arr[j + 1] = temp; &#125; &#125; 希尔排序概述希尔排序（shell sort）这个排序方法又称为缩小增量排序，是1959年D·L·Shell提出来的。该方法的基本思想是：设待排序元素序列有n个元素，首先取一个整数increment（小于n）作为间隔将全部元素分为increment个子序列，所有距离为increment的元素放在同一个子序列中，在每一个子序列中分别实行直接插入排序。然后缩小间隔increment，重复上述子序列划分和排序工作。直到最后取increment=1，将所有元素放在同一个子序列中排序为止。 希尔排序是一个不稳定的算法 时间复杂度O(n^(1.3—2)) 算法实现增量increment的取法有各种方案。最初shell提出取increment=n/2向下取整，increment=increment/2向下取整，直到increment=1。但由于直到最后一步，在奇数位置的 元素才会与偶数位置的元素进行比较，这样使用这个序列的效率会很低。后来Knuth提 出取increment=n/3向下取整+1.还有人提出都取奇数为好，也有人提出increment互质为好。 应用不同的序列会使希尔排序算法的性能有很大的差异。 12345678910111213141516171819202122232425//希尔排序void ShellSort(int arr[], int length)&#123; int increasement = length; int i, j, k; do &#123; // 确定分组的增量 increasement = increasement / 3 + 1; for (i = 0; i &lt; increasement; i++) &#123; for (j = i + increasement; j &lt; length; j += increasement) &#123; if (arr[j] &lt; arr[j - increasement]) &#123; int temp = arr[j]; for (k = j - increasement; k &gt;= 0 &amp;&amp; temp &lt; arr[k]; k -= increasement) &#123; arr[k + increasement] = arr[k]; &#125; arr[k + increasement] = temp; &#125; &#125; &#125; &#125; while (increasement &gt; 1); 快速排序概述]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ios开发crash日志符号化]]></title>
    <url>%2F2018%2F11%2F04%2Fios%E5%BC%80%E5%8F%91crash%E6%97%A5%E5%BF%97%E7%AC%A6%E5%8F%B7%E5%8C%96%2F</url>
    <content type="text"><![CDATA[本文主要分析当iOS APP crash的时候，如何符号化crash日志。 需要的工具: Xcode app崩溃时生成的.crash文件,可通过Xcode–&gt; Window–&gt; Devices and Simulators–&gt; View Device Logs从iPhone中提取出来 dsym文件(符号表文件) symbolicatecrash(可通过执行find /Applications/Xcode.app/ -name symbolicatecrash找到该文件的所在位置) 使用方式: 打开.crash文件找到其中的uuid 找到对应的dysm文件.(可通过dwarfdump --uuid xxx.dsym查看uuid是否和1的一致) 将.crash,dysm,symbolicatecrash这3个文件放在同一个文件夹下方便处理 执行命令./symbolicatecrash xxxx.crash xxxx.dSYM/ &gt; output.crash就可以看到符号化以后的崩溃堆栈信息 若报错Error: &quot;DEVELOPER_DIR&quot; is not defined at ./symbolicatecrash，则在终端执行一次后面的命令export DEVELOPER_DIR=&quot;/Applications/XCode.app/Contents/Developer&quot;，然后再执行一次4的命令. ps:最后生成的.crash文件只会解析当前项目的代码，其余的还是十六进制数据 实际操作 从iPhone中获取wspxDemo 2018-11-5, 2-42 PM.crash.crash文件如下(只保留需要的关键信息) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394Incident Identifier: 211AB31B-F097-47DC-83ED-3AC6B3AC6B05CrashReporter Key: 991d9b4c57cf7b9c00c2cabc05f20cb4812ea851Hardware Model: iPhone10,3Process: wspxDemo [1214]Path: /private/var/containers/Bundle/Application/DF7AAB28-9FF0-99EC-4EA1-16B5C50EB87C/wspxDemo.app/wspxDemoIdentifier: com.crash.CrashMeVersion: 2222 (22.22.222)Code Type: ARM-64 (Native)Role: ForegroundParent Process: launchd [1]Coalition: com.crash.CrashMe [738]Date/Time: 2018-11-05 14:42:17.6018 +0800Launch Time: 2018-11-05 14:42:17.3303 +0800OS Version: iPhone OS 12.1 (16B5089b)Baseband Version: 3.11.00Report Version: 104Exception Type: EXC_CRASH (SIGABRT)Exception Codes: 0x0000000000000000, 0x0000000000000000Exception Note: EXC_CORPSE_NOTIFYTriggered by Thread: 0Application Specific Information:abort() calledLast Exception Backtrace:(0x1dcfcfea0 0x1dc1a1a40 0x1dcede054 0x102ceb9b4 0x209fda3c8 0x209fdbb30 0x209fe157c 0x20987ea18 0x209887698 0x20987e694 0x20987f034 0x20987d134 0x20987cde0 0x209881fa0 0x209882f00 0x209881e58 0x209886d44 0x209fdfa74 0x209bca088 0x1dfa049d4 0x1dfa0f79c 0x1dfa0ee94 0x1dca0a484 0x1dc9e13f0 0x1dfa43a9c 0x1dfa43728 0x1dfa43d44 0x1dcf601cc 0x1dcf6014c 0x1dcf5fa30 0x1dcf5a8fc 0x1dcf5a1cc 0x1df1d1584 0x209fe3328 0x102cebaf0 0x1dca1abb4)Thread 0 name: Dispatch queue: com.apple.main-threadThread 0 Crashed:0 libsystem_kernel.dylib 0x00000001dcb67104 0x1dcb44000 + 1436201 libsystem_pthread.dylib 0x00000001dcbe6998 0x1dcbe0000 + 270322 libsystem_c.dylib 0x00000001dcabed78 0x1dca67000 + 3598003 libc++abi.dylib 0x00000001dc188f78 0x1dc187000 + 80564 libc++abi.dylib 0x00000001dc189120 0x1dc187000 + 84805 libobjc.A.dylib 0x00000001dc1a1e48 0x1dc19b000 + 282326 libc++abi.dylib 0x00000001dc1950fc 0x1dc187000 + 575967 libc++abi.dylib 0x00000001dc195188 0x1dc187000 + 577368 libdispatch.dylib 0x00000001dca0a498 0x1dc9a9000 + 3984889 libdispatch.dylib 0x00000001dc9e13f0 0x1dc9a9000 + 23038410 FrontBoardServices 0x00000001dfa43a9c 0x1df9f8000 + 30991611 FrontBoardServices 0x00000001dfa43728 0x1df9f8000 + 30903212 FrontBoardServices 0x00000001dfa43d44 0x1df9f8000 + 31059613 CoreFoundation 0x00000001dcf601cc 0x1dceb4000 + 70497214 CoreFoundation 0x00000001dcf6014c 0x1dceb4000 + 70484415 CoreFoundation 0x00000001dcf5fa30 0x1dceb4000 + 70302416 CoreFoundation 0x00000001dcf5a8fc 0x1dceb4000 + 68223617 CoreFoundation 0x00000001dcf5a1cc 0x1dceb4000 + 68039618 GraphicsServices 0x00000001df1d1584 0x1df1c6000 + 4646819 UIKitCore 0x0000000209fe3328 0x2096fc000 + 933559220 wspxDemo 0x0000000102cebaf0 0x102ce4000 + 3147221 libdyld.dylib 0x00000001dca1abb4 0x1dca1a000 + 2996Thread 1:0 libsystem_pthread.dylib 0x00000001dcbeece8 0x1dcbe0000 + 60648Thread 2:0 libsystem_pthread.dylib 0x00000001dcbeece8 0x1dcbe0000 + 60648Thread 3:0 libsystem_pthread.dylib 0x00000001dcbeece8 0x1dcbe0000 + 60648Thread 4:0 libsystem_pthread.dylib 0x00000001dcbeece8 0x1dcbe0000 + 60648Thread 5 name: com.apple.uikit.eventfetch-threadThread 5:0 libsystem_kernel.dylib 0x00000001dcb5bed0 0x1dcb44000 + 980001 libsystem_kernel.dylib 0x00000001dcb5b3a8 0x1dcb44000 + 951442 CoreFoundation 0x00000001dcf5fbc4 0x1dceb4000 + 7034283 CoreFoundation 0x00000001dcf5aa60 0x1dceb4000 + 6825924 CoreFoundation 0x00000001dcf5a1cc 0x1dceb4000 + 6803965 Foundation 0x00000001dd94f404 0x1dd947000 + 337966 Foundation 0x00000001dd94f2b0 0x1dd947000 + 334567 UIKitCore 0x000000020a0d0430 0x2096fc000 + 103066088 Foundation 0x00000001dda821ac 0x1dd947000 + 12906689 libsystem_pthread.dylib 0x00000001dcbeb2ac 0x1dcbe0000 + 4574010 libsystem_pthread.dylib 0x00000001dcbeb20c 0x1dcbe0000 + 4558011 libsystem_pthread.dylib 0x00000001dcbeecf4 0x1dcbe0000 + 60660Thread 0 crashed with ARM Thread State (64-bit): x0: 0x0000000000000000 x1: 0x0000000000000000 x2: 0x0000000000000000 x3: 0x000000028248b4b7 x4: 0x00000001dc198b81 x5: 0x000000016d11a570 x6: 0x000000000000006e x7: 0xffffffff00000500 x8: 0x0000000000000800 x9: 0x00000001dcbe6870 x10: 0x00000001dcbe1ef4 x11: 0x0000000000000003 x12: 0x0000000000000069 x13: 0x0000000000000000 x14: 0x0000000000000010 x15: 0x0000000000000016 x16: 0x0000000000000148 x17: 0x0000000000000000 x18: 0x0000000000000000 x19: 0x0000000000000006 x20: 0x00000001030aeb80 x21: 0x000000016d11a570 x22: 0x0000000000000303 x23: 0x00000001030aec60 x24: 0x0000000000001903 x25: 0x0000000000002103 x26: 0x0000000000000000 x27: 0x0000000000000000 x28: 0x00000002836bc408 fp: 0x000000016d11a4d0 lr: 0x00000001dcbe6998 sp: 0x000000016d11a4a0 pc: 0x00000001dcb67104 cpsr: 0x00000000Binary Images:0x102ce4000 - 0x102ceffff wspxDemo arm64 &lt;b0ffd72fc5c33a59bf97c79556430202&gt; /var/containers/Bundle/Application/DF7AAB28-9FF0-99EC-4EA1-16B5C50EB87C/wspxDemo.app/wspxDemo 从Binary Images:0x102ce4000 - 0x102ceffff wspxDemo arm64 &lt;b0ffd72fc5c33a59bf97c79556430202&gt; /var/containers/Bundle/Application/DF7AAB28-9FF0-99EC-4EA1-16B5C50EB87C/wspxDemo.app/wspxDemo中我们拿到b0ffd72fc5c33a59bf97c79556430202 在终端执行dwarfdump --uuid wspxDemo.app.dSYM/后得到如下的输出: 123wspxDemo 2018-11-05 12-56-20 dc$ dwarfdump --uuid wspxDemo.app.dSYM/UUID: 43C734F8-405F-3970-8B8D-D58575672912 (armv7) wspxDemo.app.dSYM/Contents/Resources/DWARF/wspxDemoUUID: B0FFD72F-C5C3-3A59-BF97-C79556430202 (arm64) wspxDemo.app.dSYM/Contents/Resources/DWARF/wspxDemo 对比步骤2和3的结果会发现:b0ffd72fc5c33a59bf97c79556430202和B0FFD72F-C5C3-3A59-BF97-C79556430202是一致的，所以该wspxDemo 2018-11-5, 2-42 PM.crash.crash对应的dysm就是wspxDemo.app.dSYM 在终端执行命令：./symbolicatecrash wspxDemo\ \ 2018-11-5\,\ 2-42\ PM.crash wspxDemo.app.dSYM/ &gt; output.crash得到如下的输出: 12wspxDemo 2018-11-05 12-56-20 dc$ ./symbolicatecrash wspxDemo\ \ 2018-11-5\,\ 2-42\ PM.crash wspxDemo.app.dSYM/ &gt; output.crashError: &quot;DEVELOPER_DIR&quot; is not defined at ./symbolicatecrash line 69. 报错:Error: &quot;DEVELOPER_DIR&quot; is not defined at ./symbolicatecrash line 69. 执行如下命令:export DEVELOPER_DIR=&quot;/Applications/XCode.app/Contents/Developer&quot;然后再执行5的命令.执行结果如下: `wspxDemo 2018-11-05 12-56-20 dc$ export DEVELOPER_DIR=&quot;/Applications/XCode.app/Contents/Developer&quot; wspxDemo 2018-11-05 12-56-20 dc$ ./symbolicatecrash wspxDemo\ \ 2018-11-5\,\ 2-42\ PM.crash wspxDemo.app.dSYM/ &gt; output.crash` 如果没有报任何其他错误，则说明你已经成功把crash符号了，这时打开output.crash开始查看崩溃堆栈吧 如下是符号化后的output.crash文件的内容: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130Incident Identifier: 211AB31B-F097-47DC-83ED-3AC6B3AC6B05CrashReporter Key: 991d9b4c57cf7b9c00c2cabc05f20cb4812ea851Hardware Model: iPhone10,3Process: wspxDemo [1214]Path: /private/var/containers/Bundle/Application/DF7AAB28-9FF0-99EC-4EA1-16B5C50EB87C/wspxDemo.app/wspxDemoIdentifier: com.crash.CrashMeVersion: 2222 (22.22.222)Code Type: ARM-64 (Native)Role: ForegroundParent Process: launchd [1]Coalition: com.crash.CrashMe [738]Date/Time: 2018-11-05 14:42:17.6018 +0800Launch Time: 2018-11-05 14:42:17.3303 +0800OS Version: iPhone OS 12.1 (16B5089b)Baseband Version: 3.11.00Report Version: 104Exception Type: EXC_CRASH (SIGABRT)Exception Codes: 0x0000000000000000, 0x0000000000000000Exception Note: EXC_CORPSE_NOTIFYTriggered by Thread: 0Application Specific Information:abort() calledLast Exception Backtrace:0 CoreFoundation 0x1dcfcfea0 __exceptionPreprocess + 2281 libobjc.A.dylib 0x1dc1a1a40 objc_exception_throw + 552 CoreFoundation 0x1dcede054 -[__NSSingleObjectArrayI objectAtIndex:] + 1273 wspxDemo 0x102ceb9b4 -[AppDelegate application:didFinishLaunchingWithOptions:] + 31156 (AppDelegate.m:150)4 UIKitCore 0x209fda3c8 -[UIApplication _handleDelegateCallbacksWithOptions:isSuspended:restoreState:] + 4115 UIKitCore 0x209fdbb30 -[UIApplication _callInitializationDelegatesForMainScene:transitionContext:] + 33396 UIKitCore 0x209fe157c -[UIApplication _runWithMainScene:transitionContext:completion:] + 15517 UIKitCore 0x20987ea18 __111-[__UICanvasLifecycleMonitor_Compatability _scheduleFirstCommitForScene:transition:firstActivation:completion:]_block_invoke + 7838 UIKitCore 0x209887698 +[_UICanvas _enqueuePostSettingUpdateTransactionBlock:] + 1599 UIKitCore 0x20987e694 -[__UICanvasLifecycleMonitor_Compatability _scheduleFirstCommitForScene:transition:firstActivation:completion:] + 23910 UIKitCore 0x20987f034 -[__UICanvasLifecycleMonitor_Compatability activateEventsOnly:withContext:completion:] + 107511 UIKitCore 0x20987d134 __82-[_UIApplicationCanvas _transitionLifecycleStateWithTransitionContext:completion:]_block_invoke + 77112 UIKitCore 0x20987cde0 -[_UIApplicationCanvas _transitionLifecycleStateWithTransitionContext:completion:] + 43113 UIKitCore 0x209881fa0 __125-[_UICanvasLifecycleSettingsDiffAction performActionsForCanvas:withUpdatedScene:settingsDiff:fromSettings:transitionContext:]_block_invoke + 21914 UIKitCore 0x209882f00 _performActionsWithDelayForTransitionContext + 11115 UIKitCore 0x209881e58 -[_UICanvasLifecycleSettingsDiffAction performActionsForCanvas:withUpdatedScene:settingsDiff:fromSettings:transitionContext:] + 24716 UIKitCore 0x209886d44 -[_UICanvas scene:didUpdateWithDiff:transitionContext:completion:] + 36717 UIKitCore 0x209fdfa74 -[UIApplication workspace:didCreateScene:withTransitionContext:completion:] + 53918 UIKitCore 0x209bca088 -[UIApplicationSceneClientAgent scene:didInitializeWithEvent:completion:] + 36319 FrontBoardServices 0x1dfa049d4 -[FBSSceneImpl _didCreateWithTransitionContext:completion:] + 44320 FrontBoardServices 0x1dfa0f79c __56-[FBSWorkspace client:handleCreateScene:withCompletion:]_block_invoke_2 + 25921 FrontBoardServices 0x1dfa0ee94 __40-[FBSWorkspace _performDelegateCallOut:]_block_invoke + 6322 libdispatch.dylib 0x1dca0a484 _dispatch_client_callout + 1523 libdispatch.dylib 0x1dc9e13f0 _dispatch_block_invoke_direct$VARIANT$armv81 + 21524 FrontBoardServices 0x1dfa43a9c __FBSSERIALQUEUE_IS_CALLING_OUT_TO_A_BLOCK__ + 3925 FrontBoardServices 0x1dfa43728 -[FBSSerialQueue _performNext] + 41526 FrontBoardServices 0x1dfa43d44 -[FBSSerialQueue _performNextFromRunLoopSource] + 5527 CoreFoundation 0x1dcf601cc __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__ + 2328 CoreFoundation 0x1dcf6014c __CFRunLoopDoSource0 + 8729 CoreFoundation 0x1dcf5fa30 __CFRunLoopDoSources0 + 17530 CoreFoundation 0x1dcf5a8fc __CFRunLoopRun + 103931 CoreFoundation 0x1dcf5a1cc CFRunLoopRunSpecific + 43532 GraphicsServices 0x1df1d1584 GSEventRunModal + 9933 UIKitCore 0x209fe3328 UIApplicationMain + 21134 wspxDemo 0x102cebaf0 main + 31472 (main.m:14)35 libdyld.dylib 0x1dca1abb4 start + 3Thread 0 name: Dispatch queue: com.apple.main-threadThread 0 Crashed:0 libsystem_kernel.dylib 0x00000001dcb67104 __pthread_kill + 81 libsystem_pthread.dylib 0x00000001dcbe6998 pthread_kill$VARIANT$armv81 + 2962 libsystem_c.dylib 0x00000001dcabed78 abort + 1403 libc++abi.dylib 0x00000001dc188f78 __cxa_bad_cast + 04 libc++abi.dylib 0x00000001dc189120 default_unexpected_handler+ 8480 () + 05 libobjc.A.dylib 0x00000001dc1a1e48 _objc_terminate+ 28232 () + 1246 libc++abi.dylib 0x00000001dc1950fc std::__terminate(void (*)+ 57596 ()) + 167 libc++abi.dylib 0x00000001dc195188 std::terminate+ 57736 () + 848 libdispatch.dylib 0x00000001dca0a498 _dispatch_client_callout + 369 libdispatch.dylib 0x00000001dc9e13f0 _dispatch_block_invoke_direct$VARIANT$armv81 + 21610 FrontBoardServices 0x00000001dfa43a9c __FBSSERIALQUEUE_IS_CALLING_OUT_TO_A_BLOCK__ + 4011 FrontBoardServices 0x00000001dfa43728 -[FBSSerialQueue _performNext] + 41612 FrontBoardServices 0x00000001dfa43d44 -[FBSSerialQueue _performNextFromRunLoopSource] + 5613 CoreFoundation 0x00000001dcf601cc __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__ + 2414 CoreFoundation 0x00000001dcf6014c __CFRunLoopDoSource0 + 8815 CoreFoundation 0x00000001dcf5fa30 __CFRunLoopDoSources0 + 17616 CoreFoundation 0x00000001dcf5a8fc __CFRunLoopRun + 104017 CoreFoundation 0x00000001dcf5a1cc CFRunLoopRunSpecific + 43618 GraphicsServices 0x00000001df1d1584 GSEventRunModal + 10019 UIKitCore 0x0000000209fe3328 UIApplicationMain + 21220 wspxDemo 0x0000000102cebaf0 main + 31472 (main.m:14)21 libdyld.dylib 0x00000001dca1abb4 start + 4Thread 1:0 libsystem_pthread.dylib 0x00000001dcbeece8 start_wqthread + 0Thread 2:0 libsystem_pthread.dylib 0x00000001dcbeece8 start_wqthread + 0Thread 3:0 libsystem_pthread.dylib 0x00000001dcbeece8 start_wqthread + 0Thread 4:0 libsystem_pthread.dylib 0x00000001dcbeece8 start_wqthread + 0Thread 5 name: com.apple.uikit.eventfetch-threadThread 5:0 libsystem_kernel.dylib 0x00000001dcb5bed0 mach_msg_trap + 81 libsystem_kernel.dylib 0x00000001dcb5b3a8 mach_msg + 722 CoreFoundation 0x00000001dcf5fbc4 __CFRunLoopServiceMachPort + 2363 CoreFoundation 0x00000001dcf5aa60 __CFRunLoopRun + 13964 CoreFoundation 0x00000001dcf5a1cc CFRunLoopRunSpecific + 4365 Foundation 0x00000001dd94f404 -[NSRunLoop+ 33796 (NSRunLoop) runMode:beforeDate:] + 3006 Foundation 0x00000001dd94f2b0 -[NSRunLoop+ 33456 (NSRunLoop) runUntilDate:] + 1487 UIKitCore 0x000000020a0d0430 -[UIEventFetcher threadMain] + 1368 Foundation 0x00000001dda821ac __NSThread__start__ + 10409 libsystem_pthread.dylib 0x00000001dcbeb2ac _pthread_body + 12810 libsystem_pthread.dylib 0x00000001dcbeb20c _pthread_start + 4811 libsystem_pthread.dylib 0x00000001dcbeecf4 thread_start + 4Thread 0 crashed with ARM Thread State (64-bit):x0: 0x0000000000000000 x1: 0x0000000000000000 x2: 0x0000000000000000 x3: 0x000000028248b4b7x4: 0x00000001dc198b81 x5: 0x000000016d11a570 x6: 0x000000000000006e x7: 0xffffffff00000500x8: 0x0000000000000800 x9: 0x00000001dcbe6870 x10: 0x00000001dcbe1ef4 x11: 0x0000000000000003x12: 0x0000000000000069 x13: 0x0000000000000000 x14: 0x0000000000000010 x15: 0x0000000000000016x16: 0x0000000000000148 x17: 0x0000000000000000 x18: 0x0000000000000000 x19: 0x0000000000000006x20: 0x00000001030aeb80 x21: 0x000000016d11a570 x22: 0x0000000000000303 x23: 0x00000001030aec60x24: 0x0000000000001903 x25: 0x0000000000002103 x26: 0x0000000000000000 x27: 0x0000000000000000x28: 0x00000002836bc408 fp: 0x000000016d11a4d0 lr: 0x00000001dcbe6998sp: 0x000000016d11a4a0 pc: 0x00000001dcb67104 cpsr: 0x00000000Binary Images:0x102ce4000 - 0x102ceffff wspxDemo arm64 &lt;b0ffd72fc5c33a59bf97c79556430202&gt; /var/containers/Bundle/Application/DF7AAB28-9FF0-99EC-4EA1-16B5C50EB87C/wspxDemo.app/wspxDemo 从crash文件中我们很容易定位到app挂在了AppDelegate.m文件中的第150行这里.并且可能是因为数组越界导致崩溃。从源码截图中看确实是在AppDelegate.m的150行有问题.]]></content>
      <categories>
        <category>iOS Debug</category>
      </categories>
      <tags>
        <tag>crash</tag>
        <tag>iOS debug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vim常用快捷键]]></title>
    <url>%2F2018%2F10%2F04%2Fvim%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[Mac下vim命令的使用记录快捷键，方便查询 光标移动1. 移动到行尾&quot;$&quot;，移动到行首&quot;0&quot;(数字)，移动到行首第一个字符处&quot;^&quot; 2. 移动到段首&quot;{&quot;，移动到段尾&quot;}&quot; 3. 移动到下一个词&quot;w&quot;，移动到上一个词&quot;b&quot; 4. 移动到文档开始&quot;gg&quot;，移动到文档结束&quot;G&quot; 5. 跳到第n行&quot;ngg&quot; 或 &quot;nG&quot; 或 &quot;:n&quot; 6. 移动光标到屏幕顶端&quot;H&quot;，移动到屏幕中间&quot;M&quot;，移动到底部&quot;L&quot; 7. 移动到上次编辑文件的位置 &quot;`&quot; 文本编辑1. 光标后插入&quot;a&quot;, 行尾插入&quot;A&quot; 2. 后插一行插入&quot;o&quot;，前插一行插入&quot;O&quot; 3. 删除字符插入&quot;s&quot;， 删除正行插入&quot;S&quot; 4. 光标前插入&quot;i&quot;，行首插入&quot;I&quot; 5. 删除一行&quot;dd&quot;，删除后进入插入模式&quot;cc&quot;或者&quot;S&quot; 6. 删除一个单词&quot;dw&quot;，删除一个单词进入插入模式&quot;cw&quot; 7. 删除一个字符&quot;x&quot;或者&quot;dl&quot;，删除一个字符进入插入模式&quot;s&quot;或者&quot;cl&quot; 8. 粘贴&quot;p&quot;，交换两个字符&quot;xp&quot; 9. 交换两行&quot;ddp&quot; 10. 复制&quot;y&quot;，复制一行&quot;yy&quot; 11. 拷贝当前行 &quot;yy&quot;或者&quot;Y&quot; 12. 撤销&quot;u&quot;，重做&quot;ctrl + r&quot; 13. 删除到行尾可以使用&quot;D&quot;或&quot;C&quot; 14. 删除当前字符 &quot;x&quot; 15. &quot; &gt;&gt;&quot;缩进所有选择的代码 16. &quot;&lt;&lt;&quot; 反缩进所有选择的代码 17. 合并两行&quot; J&quot; 18. 若不想保存文件，而重新打开&quot;:e!&quot; 19. 若想打开新文件 &quot;:e filename&quot;，然后使用&quot;ctrl + ^&quot;进行文件切换 配置设置1. &quot;:set number&quot;显示行号 2. &quot;:set autoindent&quot;自动缩进 3. &quot;:set ignorecase&quot;忽略大小写 4. &quot;:/+字符串&quot;搜索字符串]]></content>
      <categories>
        <category>terminal command</category>
      </categories>
      <tags>
        <tag>vim</tag>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用ida定位崩溃问题]]></title>
    <url>%2F2018%2F09%2F13%2F%E5%88%A9%E7%94%A8ida%E5%AE%9A%E4%BD%8Dcrash%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[生活，总是会给你带来意想不到的刺激与惊喜~ 问题描述由于我所在的部门是研发SDK的，所以在提供给CP用的时候，难免会有许多意想不到的问题，其中最头疼的就是应用Crash（崩溃）。可能你们会觉得定位解决崩溃也不难啊，不打个异常断点一下，或者单步调试一下不就定位到了吗？不，CP并不会给你源码，出现崩溃之后，他们查看堆栈是我们的SDK造成的，就直接丢给你如下的堆栈信息，甚至连IPA包都不给你。 堆栈信息截图 问题分析根据问题我们可以得出以下几点有用的信息 通过符号化的第8个堆栈信息可以看出确实是因为我方的SDK而crash（因为该函数调用是我方提供给CP调用的接口） SIGSEGV: SIGSEGV是当一个进程执行了一个无效的内存引用，或发生段错误时会发出的信号。 从上到下总共0到11个堆栈信息（部分截图)，其中对我们分析有用的是0到8，由0可以看出应用是崩在strnlen这个函数。 定位途径 首先想到的肯定是直接在项目中搜索strnlen这个函数，此方法为下下测因为： 项目中的strnlen这个函数可能多处用到，so精准定位难度大。 strnlen函数可能是其他的库函数调用的，比如本例中正是strncpy调用的strnlen，这样你搜索strnlen是定位不到的crash的地方的。 通过符号化的堆栈信息，搜索代码中对应的调用关系。此法比1方法好一点，但还是定位难度大，因为可能由于某种原因堆栈关系并不是下一级内调用上一级的，比如本例，sre_regex_parse并没有调用sslerr_to_curlerr这个函数。 通过未符号化的地址，再利用IDA去逆向砸壳过的项目，便可通过搜索地址，直接精准定位，但此法需要懂汇编与一些其他技能。本文便使用法3定位。 定位步骤 找个越狱机，从appstore上下载对应的应用，并进行砸壳供后续使用。（后续会写一篇砸壳的大致步骤） 使用IDA逆向砸壳后的.decrypted包。 查看未符号化图中的第三条： 1DYZB 0x00000001021626d4 0x0000000100054000 + 34662100 其中34662100为改函数在内存中的偏移地址，把他转为16进制为0x210E6D4。 接着因为IDA软件本身有一个初始的偏移地址，查看方法为： IDA——Edit——segments——rebase program——value 两个地址相加： 0x210E6D4 + 0x100000000 = 0x10210E6D4 在IDA中按下地址跳转键“g”，输入上述地址跳转到0x10210E6D4，图为： 其中框1为崩溃地址，可以看出为调用了strncpy之后崩溃。 搜索框2中的特殊字符串，定位到代码大概位置。 再搜索框3，4的函数。 再看三条红实心框的跳转，其中框6中： w21 #0 与框框5中： ADD w21，w21，#1 CMP w20，w21 B.NE loc_1021E694 可翻译为：申请一个变量为0，接着执行一段代码，接着使其加1，并与w20中的值比较，然后跳转。这正是一个for循环。 综上，crash位置如图： 崩溃原因]]></content>
      <categories>
        <category>iOS Debug</category>
      </categories>
      <tags>
        <tag>iOS crash</tag>
        <tag>ida的初步使用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[the description of themes landscape]]></title>
    <url>%2F2018%2F09%2F10%2Fthe-description-of-themes-landscape%2F</url>
    <content type="text"><![CDATA[LandscapeA brand new default theme for Hexo. Preview InstallationInstall1$ git clone https://github.com/hexojs/hexo-theme-landscape.git themes/landscape Landscape requires Hexo 2.4 and above. If you would like to enable the RSS, the hexo-generate-feed plugin is also required. EnableModify theme setting in _config.yml to landscape. Update12cd themes/landscapegit pull Configuration123456789101112131415161718192021222324# Headermenu:Home: /Archives: /archivesrss: /atom.xml# Contentexcerpt_link: Read Morefancybox: true# Sidebarsidebar: rightwidgets:- category- tag- tagcloud- archives- recent_posts# Miscellaneousgoogle_analytics:favicon: /favicon.pngtwitter:google_plus: menu - Navigation menu rss - RSS link excerpt_link - “Read More” link at the bottom of excerpted articles. false to hide the link. fancybox - Enable Fancybox sidebar - Sidebar style. You can choose left, right, bottom or false. widgets - Widgets displaying in sidebar google_analytics - Google Analytics ID favicon - Favicon path twitter - Twiiter ID google_plus - Google+ ID FeaturesFancyboxLandscape uses Fancybox to showcase your photos. You can use Markdown syntax or fancybox tag plugin to add your photos. 123![img caption](img url)&#123;% fancybox img_url [img_thumbnail] [img_caption] %&#125; SidebarYou can put your sidebar in left side, right side or bottom of your site by editing sidebar setting. Landscape provides 5 built-in widgets: category tag tagcloud archives recent_posts All of them are enabled by default. You can edit them in widget setting. DevelopmentRequirements Grunt 0.4+ Hexo 2.4+ Grunt tasks default - Download Fancybox and Font Awesome. fontawesome - Only download Font Awesome. fancybox - Only download Fancybox. clean - Clean temporarily files and downloaded files.]]></content>
      <categories>
        <category>hexo themes</category>
      </categories>
      <tags>
        <tag>landscape</tag>
        <tag>hexo主题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[How to use themes next]]></title>
    <url>%2F2018%2F09%2F09%2Fthemes-next-readme%2F</url>
    <content type="text"><![CDATA[NexT v6.0.0 here :triangular_flag_on_post: NexT NexT 是一个高质量并且优雅的Hexo 主题。这是精心制作做出来的 hexo 主题。 NexT 使用文档 | English Documentation 实时预览 Live Preview :heart_decoration: Muse 方案: LEAFERx | XiaMo | OAwan :six_pointed_star: Mist 方案: Jeff | uchuhimo | xirong :pisces: Pisces 方案: Vi | Acris | Rainy :gemini: Gemini 方案: Ivan.Nginx | Raincal | Dandy 更多 NexT 例子点击 这里. 安装 Installation1. 在终端切换到hexo 根目录. 在hexo目录下一定有 node_modules, source, themes 和其他文件夹:123$ cd hexo$ ls_config.yml node_modules package.json public scaffolds source themes 2. 从 github 上获取主题 。这里有几种方式来获取主题: 下载[最新发布的版本][releases-latest-url] Download tagged release version 在大多数情况下 稳定。 推荐用户下载这个。 [![curl-tar-wget-image]][curl-tar-wget-url] 12 $ mkdir themes/next $ curl -s https://api.github.com/repos/iissnan/hexo-theme-next/releases/latest | grep tarball_url | cut -d '"' -f 4 | wget -i - -O- | tar -zx -C themes/next --strip-components=1 下载[标签发布版本][releases-url] Download tagged release version您必须定义版本。从[标签列表][tags-url]里选择版本替换`v5.1.2`。 [![curl-tar-image]][curl-tar-url] 12 $ mkdir themes/next $ curl -L https://api.github.com/repos/iissnan/hexo-theme-next/tarball/v5.1.2 | tar -zxv -C themes/next --strip-components=1 [![git-image]][git-url] 1 $ git clone --branch v5.1.2 https://github.com/iissnan/hexo-theme-next themes/next ### 下载[最新的 master 分支][download-latest-url] Download latest master branch 可能会 **不稳定**, 但是包含最新的特色，推荐开发者下载. [![curl-tar-image]][curl-tar-url] 12 $ mkdir themes/next $ curl -L https://api.github.com/repos/iissnan/hexo-theme-next/tarball | tar -zxv -C themes/next --strip-components=1 [![git-image]][git-url] 1 $ git clone https://github.com/iissnan/hexo-theme-next themes/next 使用克隆命令，你将得到**整个存储库**。而且在任何时候你都可以切换到任何标签发布版本。 获取标签列表： 12345678 $ cd themes/next $ git tag -l … v5.0.0 v5.0.1 v5.1.0 v5.1.1 v5.1.2 例如, 你想要切换到`v5.1.0` [标签发布版本][tags-url]. 输入以下命令: 1234 $ git checkout tags/v5.1.0 Note: checking out 'tags/v5.1.0'. … HEAD now on 1f72f68... CSS: Remove global list-style setting of ul 如果你想切换回 [master 分支][commits-url]的话, 输入这个命令: 1 $ git checkout master **3.** 在 **hexo 根目录下** 的配置文件`_config.yml`里设置主题: theme: next ### Bugs 对于那些遇到 **Error: Cannot find module &apos;hexo-util&apos;** [问题](https://github.com/iissnan/hexo-theme-next/issues/1490)的人, 请检查你的NPM 版本. - `版本 &gt; 3`: 如果仍然不行的话，请移除 `node_modules` 文件 然后重新安装，使用 `npm install`命令。 - `版本 &lt; 3`: 请通过`npm install --save-dev hexo-util`命令添加`hexo-util`到你的站点包依赖里 ## 更新 Update 12 $ cd themes/next $ git pull ### Bugs &gt; 提交您的更改或存储它们，然后才能合并。 您必须提交，存储或放弃本地更改. 看 [here](https://stackoverflow.com/a/15745424/5861495) 是如何做的。 ### 使用Hexo data files([#328](https://github.com/iissnan/hexo-theme-next/issues/328))配置主题 Theme configurations using Hexo data files #328 目前升级 NexT 主题的时候并不是非常的流畅。若使用 `git pull` 的方式，很多时候可能会产生冲突；而下载新版本覆盖安装的方式又需要手动合并主题的 `_config.yml` 文件。 在此修改之前， NexT 建议将配置分离，一部分在 站点的配置文件中，另外一部分在主题的配置文件中。将需要自定的选项放置在 站点配置文件中，从而脱离避免更新主题时可能遇到的麻烦。这种方式是可行，但是有一些缺点： 1. 配置分离成了两个部分 2. 用户可能会疑惑一些选项该放置在哪里比较合适 为了解决这个问题， NexT 将会使用 Hexo 的 [Data Files](https://hexo.io/docs/data-files.html) 。然而由于 Data Files 是在 Hexo 3 版本时引进的，所以要使用这个特性，需要 Hexo 的版本不低于 3。 若你比较喜欢 Hexo 2.x 版本，可以继续使用原先的配置方式。 NexT 保持着向下兼容。 #### 特性 Benefits 通过这个特性，你可以将所有的主题配置放置在站点的 `source/_data/next.yml` 文件中。原先放置在 站点配置文件 中的选项可以迁移到新的位置，同时，主题配置文件可以不用做任何修改。若后续版本有配置相关的改动时，你仅需在 `next.yml` 中做相应调整即可 #### 如何使用这个特性 How to use this feature 1. 请先确保你所使用的 Hexo 版本在 3 以上 2. 在站点的 `source/_data` 目录下新建 `next.yml` 文件（`_data`目录可能需要新建） 3. 迁移站点配置文件和主题配置文件中的配置到 `next.yml` 中 4. 使用 `--config source/_data/next.yml` 参数启动服务器, 生成或者部署。\ 例如: `hexo clean --config source/_data/next.yml &amp;&amp; hexo g --config source/_data/next.yml`。 ## 特色 Features ### 支持多国语言, 包括: :cn: 简体中文 &amp; 繁体中文&lt;br&gt; :us: 英语&lt;br&gt; :ru: 俄语&lt;br&gt; :fr: 法语&lt;br&gt; :de: 德语&lt;br&gt; :jp: 日语&lt;br&gt; :indonesia: 印度尼西亚语&lt;br&gt; :portugal: 葡萄牙语 (巴西)&lt;br&gt; :kr: 朝鲜语&lt;br&gt; :it: 意大利语&lt;br&gt; :netherlands: 荷兰语 默认语言是英语。 1234567891011121314 language: en # language: zh-Hans # language: zh-hk # language: zh-tw # language: ru # language: fr-FR # language: de # language: ja # language: id # language: pt # language: pt-BR # language: ko # language: it # language: nl-NL 在站点配置文件`_config.yml`中可以将语言切换成中文 1 language: zh-Hans ### 评论支持 Comment support NexT 已经原生支持 `多说` and `Disqus` 评论系统。 添加以下代码到你的主题配置文件 `_config.yml`: 123 duoshuo: enable: true shortname: your-duoshuo-shortname 或者 1 disqus_shortname: your-disqus-shortname ### 标签页 Tags page &gt; 添加一个标签页面，里面包含您网站中的所有标签。 - 创建一个名为 `tags` 页面 hexo new page &quot;tags&quot; - 编辑标签页, 设置页面类型为`tags`. title: All tags date: 2014-12-22 12:39:04 type: &quot;tags&quot; - 添加 `tags` 到主题配置文件 `_config.yml` 里: menu: home: / archives: /archives tags: /tags ### 分类页 Categories page &gt; 添加一个分类页面，里面包含您网站中的所有分类。 - 创建一个名为 `categories` 页面 hexo new page &quot;categories&quot; - 编辑分类页, 设置页面类型为 `categories`. title: All categories date: 2014-12-22 12:39:04 type: &quot;categories&quot; - 添加 `categories` 到主题配置文件 `_config.yml` 里: menu: home: / archives: /archives categories: /categories ### 社交媒体 Social Media NexT 可以自动添加链接到您的社交媒体帐户里: 123456 social: GitHub: your-github-url Twitter: your-twitter-url Weibo: your-weibo-url DouBan: your-douban-url ZhiHu: your-zhihu-url ### Feed 链接 Feed link &gt; 显示 feed 链接。 在主题配置文件`_config.yml`里设置`rss` , 如下所示: 1. `rss: false` 会禁用 feed 链接。 2. `rss: ` 使用站点 feed 链接。这是默认的选项。 按照插件[hexo-generator-feed](https://github.com/hexojs/hexo-generator-feed)的README中的安装说明进行操作。在完成这个插件的配置后，Feed链接也生成好了 3. `rss: http://your-feed-url` 设置你的 feed 链接. ### 内置5种代码高亮主题 Up to 5 code highlight themes built-in NexT 使用的是 [Tomorrow 主题](https://github.com/chriskempson/tomorrow-theme) ，一共有5种主题供你选择。 Next 默认使用 `normal`. 下面是 `normal` 和 `night` 主题的预览: ![Tomorrow Normal Preview](http://iissnan.com/nexus/next/tomorrow-normal.png) ![Tomorrow Night Preview](http://iissnan.com/nexus/next/tomorrow-night.png) 查看更多信息点击[Tomorrow 主题](https://github.com/chriskempson/tomorrow-theme)。 ## 配置 Configuration NexT 的配置很少 12345678910111213141516171819202122 # Menu configuration. menu: home: / archives: /archives # Favicon favicon: /favicon.ico # Avatar (put the image into next/source/images/) # can be any image format supported by web browsers (JPEG,PNG,GIF,SVG,..) avatar: /default_avatar.png # Code highlight theme # available: normal | night | night eighties | night blue | night bright highlight_theme: normal # Fancybox for image gallery fancybox: true # Specify the date when the site was setup since: 2013 ## 浏览器支持 Browser support ![Browser support](http://iissnan.com/nexus/next/browser-support.png) [![Browser Stack](.github/browserstack_logo.png)](https://www.browserstack.com/) &gt;**BrowserStack** is a cloud-based cross-browser testing tool that enables developers to test their websites across various browsers on different operating systems and mobile devices, without requiring users to install virtual machines, devices or emulators. ## 贡献 Contributing 接受各种形式的贡献，包括不限于提交问题与需求，修复代码。等待您的`Pull Request`。 Any types of contribution are welcome. Thanks. **ATTENTION! Contributors on Chinese docs needed!**\ Need to translate from [English docs](README.md) to Chinese docs.\ Any help wanted!\ Thank&apos;s a lot! ## 开发 Development NexT 主旨在于简洁优雅且易于使用，所以首先要尽量确保 NexT 的简洁易用性。 NexT is built for easily use with elegant appearance. First things first, always keep things simple. ## [开发历史 Changelog](https://github.com/iissnan/hexo-theme-next/wiki/Changelog) [browser-image]: https://img.shields.io/badge/browser-%20chrome%20%7C%20firefox%20%7C%20opera%20%7C%20safari%20%7C%20ie%20%3E%3D%209-lightgrey.svg [browser-url]: https://www.browserstack.com [gitter-image]: https://badges.gitter.im/Join%20Chat.svg [gitter-url]: https://gitter.im/iissnan/hexo-theme-next?utm_source=badge&amp;utm_medium=badge&amp;utm_campaign=pr-badge&amp;utm_content=badge [travis-image]: https://travis-ci.org/iissnan/hexo-theme-next.svg?branch=master [travis-url]: https://travis-ci.org/iissnan/hexo-theme-next?branch=master &quot;Travis CI&quot; [hexo-image]: https://img.shields.io/badge/hexo-%3E%3D%203.0-blue.svg [hexo-url]: http://hexo.io [mnt-image]: https://img.shields.io/maintenance/yes/2017.svg [rel-image]: https://img.shields.io/github/release/iissnan/hexo-theme-next.svg &lt;!--[lic-image]: https://img.shields.io/npm/l/hexo-theme-next.svg--&gt; [lic-image]: https://img.shields.io/dub/l/vibe-d.svg [git-image]: https://img.shields.io/badge/install%20with%20-git-blue.svg [curl-tar-image]: https://img.shields.io/badge/install%20with%20-curl%20%7C%20tar-blue.svg [curl-tar-wget-image]: https://img.shields.io/badge/install%20with%20-curl%20%7C%20tar%20%7C%20wget-blue.svg [git-url]: http://lmgtfy.com/?q=linux+git+install [curl-tar-url]: http://lmgtfy.com/?q=linux+curl+tar+install [curl-tar-wget-url]: http://lmgtfy.com/?q=linux+curl+tar+wget+install [download-latest-url]: https://github.com/iissnan/hexo-theme-next/archive/master.zip [releases-latest-url]: https://github.com/iissnan/hexo-theme-next/releases/latest [releases-url]: https://github.com/iissnan/hexo-theme-next/releases [tags-url]: https://github.com/iissnan/hexo-theme-next/tags [commits-url]: https://github.com/iissnan/hexo-theme-next/commits/master]]></content>
      <categories>
        <category>hexo themes</category>
      </categories>
      <tags>
        <tag>hexo主题</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用栈平衡符号]]></title>
    <url>%2F2018%2F08%2F04%2F%E5%B9%B3%E8%A1%A1%E7%AC%A6%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[栈的应用-平衡符号栈（stack）又名堆栈，它是一种运算受限的线性表。 其限制是仅允许在表的一端进行插入和删除运算， 这一端被称为栈顶，相对地，把另一端称为栈底。 平衡符号化解释 编译器检查你的程序的语法错误，但是常常由于少一个符号（如遗漏一个花括号或是注释起始符）引起编译器列出上百行的诊断，而真正的错误并没有找出。在这种情况下一个有用的程序就是检验是否每件事情都能成对出现。于是，每一个右花括号、右方括号及右圆括号必然对应其相应的左括号。序列[()]是合法的，但[(])是错误的。 编程实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;typedef struct Mystack *Stack;struct Mystack &#123; int Capacity; /* 栈的容量 */ int Top_of_stack; /* 栈顶下标 */ char *Array; /* 存放栈中元素的数组 */&#125;;/* 栈的创建 */static Stack CreateStack(int Max)&#123; Stack S; S = malloc(sizeof(struct Mystack)); if (S == NULL) printf(&quot;Create stack error!\n&quot;); S-&gt;Array = malloc(sizeof(char) * Max); if (S-&gt;Array == NULL) printf(&quot;Create stack array error!\n&quot;); S-&gt;Capacity = Max; S-&gt;Top_of_stack = 0; return S;&#125;/* 释放栈 */static void DisposeStack(Stack S)&#123; if (S != NULL) &#123; free(S-&gt;Array); free(S); &#125;&#125;/* 判断一个栈是否是空栈 */static int IsEmptyStack(Stack S)&#123; return !S-&gt;Top_of_stack;&#125;/* 判断一个栈是否满栈 */static int IsFullStack(Stack S)&#123;// if (S-&gt;Top_of_stack == S-&gt;Capacity - 1) &#123;// return 1;// &#125;// return 0; return S-&gt;Top_of_stack == S-&gt;Capacity - 1;&#125;/* 数据入栈 */static int PushStack(int x, Stack S)&#123; if (!IsFullStack(S)) &#123; S-&gt;Array[S-&gt;Top_of_stack++] = x; return 0; &#125; printf(&quot;The stack is full!&quot;); return -1;&#125;/* 数据出栈 */static int PopStack(Stack S)&#123; if (!IsEmptyStack(S)) &#123; S-&gt;Top_of_stack--; return 0; &#125; printf(&quot;The Stack is empty!\n&quot;); return -1;&#125;/* 将栈顶返回 */static char TopOfStack(Stack S)&#123; if (!IsEmptyStack(S)) return S-&gt;Array[S-&gt;Top_of_stack - 1]; printf(&quot;The Stack is empty!\n&quot;); return 0;&#125;int main (int argc, const char * argv[])&#123; int i, len; char str[100]; printf(&quot;Please input the symbol that you want to balance: \n&quot;); scanf(&quot;%s&quot;, str); len = (int)strlen(str); /* 根据序列的长度来创建栈 */ struct Mystack *my_stack = CreateStack(len+1); for (i = 0; i &lt; len; i++) &#123; if (str[i] == &apos;&#123;&apos; || str[i] == &apos;[&apos; || str[i] == &apos;(&apos; ) &#123; if (PushStack(str[i], my_stack) != 0) &#123; printf(&quot;Push %d error!&quot;,str[i]); &#125; &#125; if (str[i] == &apos;&#125;&apos;) &#123; if (TopOfStack(my_stack) == &apos;&#123;&apos;) PopStack(my_stack); else break; &#125; else if (str[i] == &apos;]&apos;) &#123; if (TopOfStack(my_stack) == &apos;[&apos;) PopStack(my_stack); else break; &#125; else if (str[i] == &apos;)&apos;) &#123; if (TopOfStack(my_stack) == &apos;(&apos;) PopStack(my_stack); else break; &#125; &#125; /* 如果最后占空则序列是合法的 */ if(IsEmptyStack(my_stack)) printf(&quot;The symbol that you input is balance!\n&quot;); else printf(&quot;The symbol that you input is imbalance!\n&quot;); DisposeStack(my_stack); return 0;&#125; 测试结果]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>栈</tag>
        <tag>平衡符号</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用命令集合]]></title>
    <url>%2F2018%2F02%2F04%2F%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[工作中常用命令行 年纪大了记性不好，随手做个记录。 openssl相关 把.cer二进制证书转换成.crt证书 openssl x509 -inform der -in GlobalSign_Root_CA.cer -out GlobalSign.crt 验证user_cert是否是根证书root_cert签名的 openssl verify -CAfile ROOT_CERT USER_CERT 把.crt与.cer合并成.der格式证书 openssl x509 -in 你的证书.crt -out 你的证书.cer -outform der 查看某个域名的证书情况 openssl s_client -showcerts -verify 5 -connect www.baidu.com:443 nginx相关 查看nginx进程 ps -ef|grep nginx 开启nginx sudo nginx 关闭nginx sudo nginx -s stop 重载nginx sudo nginx -s reload nginx配置文件路径 /usr/local/etc/nginx/nginx.cnf iOS tools dumpdecrypted.dylib 1，将dumpdecrypted.dylib拷贝到手机的(iOS8)： /var/mobile/Containers/Data/Application/xxx-xxx/Documents， 在iOS7中是： /var/mobile/Applications/xxx-xxx/Documents 2，iOS8然后再cd到3中的目录下执行: DYLD_INSERT_LIBRARIES=dumpdecrypted.dylib /var/mobile/Containers/Bundle/Application/xxx-xxx/yyy.app/yyy iOS7然后再cd到3中的目录下执行: DYLD_INSERT_LIBRARIES=dumpdecrypted.dylib /var/mobile/Applications/xxx-xxx/yyy.app/yyy 3，然后就会生成： yyy.decrypted ssh（默认密码alpine） ssh root@ip -p 2222 scp拷贝 scp -P&lt;port&gt; root@&lt;remoteIpAddress&gt;:&lt;remote dir path&gt; &lt;source file path&gt; tcpdump抓手机lo的包 tcpdump -i lo0 -s0 -w xxxx.pcapng class dump ./class-dump -H xx.app -o outputs 查看xcode版本 xcode-select -p 选择xcode版本 sudo xcode-select -s + xcode地址 iproxy iproxy 本机端口 手机端口 其他 检查某个端口服务是否开启 telnet ip port 查看占用9000端口的进程 sudo lsof -i :9000 杀死pid为1000的进程 sudo kill -9 1000]]></content>
      <categories>
        <category>terminal command</category>
      </categories>
      <tags>
        <tag>Mac terminal command</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS编写高质量Objective-C代码（一）]]></title>
    <url>%2F2017%2F10%2F15%2FiOS%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FObjective-C%E4%BB%A3%E7%A0%81%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[iOS编写高质量Objective-C代码（一）边读边写勿忘记。 前言由于最近在阅读《Effective Objective-C 2.0》这本书，随手做个记录方便查阅，也希望能够帮到广大iOS开发者些许。 一、Objective-C起源Objective-C与C++，Java等面向对象编程语言类似，但在某些方面上又有着很大的区别。 Objective-C由Smalltalk语言演变而来，而Smalltalk语言是消息传递型语言的鼻祖，所以Objective-C是使用消息传递机制而非函数调用。 1234567// Objective-C(消息传递)Object *obj = [Object new];[obj performWith:parameter1 and:parameter2];// C++(函数调用)Object *obj = new Object;obj-&gt;perform(parameter1, parameter2); 消息传递：消息结构的语言，其运行时所执行的代码由运行环境来决定，消息结构的语言，无论是否多态，总是在运行期才会去查找所要执行的方法。事实上，编译器甚至不关心接收消息的对象的什么类型，接收消息的对象问题也要在运行时处理，这个过程叫做“动态绑定”。 函数调用：函数调用的语言，则由编译器决定。如果示例代码中调用的函数是多态的，那么在运行时要按照“虚方法表”来查找到底要执行哪个函数实现。 二、指针在OC里面，指针主要是用来指示对象，其基本用法与C语言类似。 例如：声明一个字符串 1NSString *myStr = @&quot;www.hungrytocode.github.io&quot;; 该语句声明了一个myStr指针指向了NSString类型，其指向的地址所存放的内容是www.hungrytocode.github.io。该块内存是分配在栈之上的。 1NSString *myStr = [[NSString alloc] initWithFormat:@&quot;www.hungrytocode.github.io&quot;]; 该语句效果与上一句一样，但该语句的内存是分配在堆之上的，需要程序员手工释放，在现在中由ARC释放。后续会有ARC相关的文章。 三、在.h头文件中尽量少引入其他头文件，减少编译时间。好处： 在头文件中引用头文件会在编译时就完全得知所引入头文件的所有接口信息，例如在A.h中导入B.h，将来如果在SubA.h中导入了A.h，隐式地导入了B.h，增加不必要的编译，内聚度低；在实现文件中导入头文件，编译器只会在需要的时候得知类的接口信息，会减少编译时间，并且类之间的耦合度会降低。 避免两个在.h头文件中的循环引用导致不能正确编译。 尽量在.m文件中#import其他类，如果在.h头文件中必须用到其他类的话，可以使用@class向前声明该类。 For Example：123456789//myclass.h@class yourclass@interface xxx : yyy//...@end 再在myclass.m中引入该类： 12345//myclass.m#import yourclass.h//... 四、尽量使用字面量语法好处 oc的语法很繁杂，在定义一些数组、字典的时候要写很长的方法。通过字面量语法可以像c语言那样定义数组等，可以缩减代码长度，提高代码的可读性和维护性。 在xcode4.5，ios6以上版本已经全面支持以下的字面量。 局限性 用字面量创建数组或者字典时，当值为nil的时候会抛出异常。 For Example： 字面量字符串： 1NSString *str = @&quot;www.hungrytocode.github.io&quot;; 字面量数值: 123456NSNumber *num = @(1);NSNumber *floatNum = @(1.0);int x = 5;int y = 6;NSNumber *myNum = @(x * y); 字面量数组: 1234567891011NSArray *animals = @[@&quot;cat&quot;, @&quot;pig&quot;, @&quot;dog&quot;];NSString *obj1 = @&quot;str1&quot;;NSString *obj2 = nil;NSString *obj3 = @&quot;str3&quot;;//非字面量NSArray *array1 = [NSArray arrayWithObjects:obj1, obj2, obj3, nil]; //字面量NSArray *array2 = @[obj1, obj2, obj3]; 在上述的中，obj2为nil，当使用非字面量方法创建array1的时候，array1里面只会有obj1这个对象，原因是arrayWithObjects方法是依次处理各个参数直到发现nil，而obj2刚好是nil。 而当使用字面量方法的时候，由于字面量的数组的值不能为nil，否则会抛出异常。这两个微妙的区别表明，使用字面量更加安全，因为尽早抛出异常总比在运行debug的时候才发现array1只有一个obj1来的好。 字面量字典 12NSDictionary *myDic = @&#123;@&quot;key1&quot;: @&quot;hungrytocode&quot;, @&quot;key2&quot;: @&quot;github.io&quot;&#125;; 使用字面量字典与字面量数组一样，如果元素中有nil值，则会抛出异常。 字面量语法有个小小的限制，就是除了字符串以外,所创建出来的对象必须属于Foundation框架才行。如果自定义了这些类的子类，则无法用字面量语法创建其对象。要想创建自定义子类的实例，必须采用“非字面量语法”。 使用mutableCopy 用字面量语法创造出来的对象默认都是不可变对象，如果需要可变对象，执行一步 mutableCopy。 1NSMutableString *mutableStr = [@&quot;hungrytocode&quot; mutableCopy]; 多用类型常量，少用#define预处理指令本人亲身感受：几乎每个常量都是用#define写的hhh... for example #define ANIMATION_DURATION 0.3 与 static const NSTimeInterval kAnimationDuration = 0.3 相比，前者没有任何的类型信息，而后者清楚的描述了常量的类型属于NSTimeInterval 若只在这个类中使用该常量，不打算公开它，可以这样写： 12345678910111213//HungrtCodeView.h#import &lt;UIKit/UIKit.h&gt;@interface hungryCodeView : UIView//do something...@end//HungrtCodeView.m#import &quot;hungryCodeView.h&quot;static const NSTimeInterval kAnimationDuration = 0.3;@implementation hungryCodeView//do something...@end 上述常量用const修饰，当试图修改它的时候，编译器就会报错提醒。 而static则意味着该变量仅在定义此变量的编译单元中可见。如果不加static则编译器会为它创建一个外部富豪，此时若是在另一个编译单元中也声明了同名变量，那么编译器就会抛出一条错误信息。 若打算公开这个常量，即全局变量，可以这样写： 12345//hungryCodeView.hextern const NSTimeInterval HungryCodeViewAnimatedDuration;//hungryCodeView.mconst NSTimeInterval HungryCodeViewAnimatedDuration = 0.3 这样在其他类中，都可以用到HungryCodeViewAnimatedDuration这个常量。 用枚举表示状态、选项、状态码For Example 枚举语法： 123456789//声明enum HungryCodeState &#123; HungryCodeStateDisconnected, HungryCodeStateConnecting, HungryCodeStateConnected,&#125;;//使用enum HungryCodeState state = HungryCodeStateDisconnected; 若是在声明后面加上typedef enum HungryCodeState HungryCodeState; 则在使用的时候HungryCodeState state = HungryCodeStateDisconnected;即可。 向前声明指定底层类型： enum HungryCodeState : NSInteger {/*...*/}; 定义选项枚举： 123456789enum UIViewAutoresizing &#123; UIViewAutoresizingNone = 0, UIViewAutoresizingFlexibleLeftMargin = 1 &lt;&lt; 0, UIViewAutoresizingFlexibleWidth = 1 &lt;&lt; 1, UIViewAutoresizingFlexibleRightMargin = 1 &lt;&lt; 2, UIViewAutoresizingFlexibleTopMargin = 1 &lt;&lt; 3, UIViewAutoresizingFlexibleHeight = 1 &lt;&lt; 4, UIViewAutoresizingFlexibleBottomMargin = 1 &lt;&lt; 5,&#125; 使用方法如下： 12345enum UIViewAutoresizing resizing = UIViewAutoresizingFlexibleWidth | UIViewAutoresizingFlexibleWidth;if(resizing &amp; UIViewAutoresizingFlexibleWidth) &#123; // UIViewAutoresizingFlexibleWidth is set&#125; 使用NS_ENUM与NS_OPTIONS宏声明枚举 1234567891011typedef NS_ENUM(NSUInteger, HungryCodeState) &#123; HungryCodeStateDisconnected, HungryCodeStateConnecting, HungryCodeStateConnected,&#125;;typedef NS_OPTIONS(NSUInteger, UIViewAutoresizing) &#123; UIViewAutoresizingFlexibleLeftMargin = 1 &lt;&lt; 0, UIViewAutoresizingFlexibleWidth = 1 &lt;&lt; 1, UIViewAutoresizingFlexibleRightMargin = 1 &lt;&lt; 2,&#125; switch语句里的枚举 1234567891011121314151617typedef NS_ENUM(NSUInteger, HungryCodeState) &#123; HungryCodeStateDisconnected, HungryCodeStateConnecting, HungryCodeStateConnected,&#125;;switch (_currentState) &#123; HungryCodeStateDisconnected: //do something with disconnected... break; HungryCodeStateConnecting: //do something with connecting... break; HungryCodeStateConnected: //do something with connected: break;&#125; 注意，在用switch语句的时候我们通常习惯性加上default分支，然而若是用枚举定义状态机，最好不要有default分支，这样的话，如果稍后又加了一种状态，那么编译器就会发出警告，提示新加入的状态并未在switch分支中处理。如果有default分支，那么它将会处理这个新加入的状态，导致编译器不发出警告。]]></content>
      <categories>
        <category>Effective Objective-C</category>
      </categories>
      <tags>
        <tag>OC</tag>
        <tag>Effevtice OC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TLS/SSL协议详解]]></title>
    <url>%2F2017%2F02%2F03%2FSSL-TLS%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[记录TLS/SSL协议,包括握手协议(handshake protocol)、记录协议(record protocol)、警告协议(alert protocol)的相关内容 TLS/SSL协议详解之握手协议功能实现主要算法TLS/SSL的功能实现主要依赖于三类基本算法：散列函数 Hash、对称加密和非对称加密，其利用非对称加密实现身份认证和密钥协商，对称加密算法采用协商的密钥对数据加密，基于散列函数验证信息的完整性。 身份验证CA和证书为了能够验证服务器的身份信息，为此需要引入权威的第三方机构CA。CA 负责核实公钥的拥有者的信息，并颁发认证”证书”，同时能够为使用者提供证书验证服务，即PKI体系(PKI基础知识) 证书认证流程 服务方S向第三方机构CA提交公钥、组织信息、个人信息(域名)等信息并申请认证; CA通过线上、线下等多种手段验证申请者提供信息的真实性，如组织是否存在、企业是否合法，是否拥有域名的所有权等 如信息审核通过，CA会向申请者签发认证文件-证书。证书包含以下信息：申请者公钥、申请者的组织信息和个人信息、签发机构CA的信息、有效时间、证书序列号等信息的明文，同时包含一个签名;签名的产生算法：首先，使用散列函数计算公开的明文信息的信息摘要，然后，采用CA的私钥对信息摘要进行加密，密文即签名; 客户端 C 向服务器 S 发出请求时，S 返回证书文件; 客户端 C 读取证书中的相关的明文信息，采用相同的散列函数计算得到信息摘要，然后，利用对应CA的公钥解密签名数据，对比证书的信息摘要，如果一致，则可以确认证书的合法性，即公钥合法; 客户端然后验证证书相关的域名信息、有效时间等信息; 客户端会内置信任CA的证书信息(包含公钥)，如果CA不被信任，则找不到对应 CA的证书，证书也会被判定非法。 在这个过程注意几点： 申请证书不需要提供私钥，确保私钥永远只能服务器掌握; 证书的合法性仍然依赖于非对称加密算法，证书主要是增加了服务器信息以及签名; 内置 CA 对应的证书称为根证书，颁发者和使用者相同，自己为自己签名，即自签名证书（为什么说”部署自签SSL证书非常不安全”） 证书 = 公钥 + 申请者与颁发者信息 + 签名; 证书吊销CA 机构能够签发证书，同样也存在机制宣布以往签发的证书无效。证书使用者不合法，CA 需要废弃该证书;或者私钥丢失，使用者申请让证书无效。主要存在两类机制：CRL 与 OCSP。 CRL(Certificate Revocation List), 证书吊销列表，一个单独的文件。该文件包含了 CA 已经吊销的证书序列号(唯一)与吊销日期，同时该文件包含生效日期并通知下次更新该文件的时间，当然该文件必然包含 CA 私钥的签名以验证文件的合法性。证书中一般会包含一个 URL 地址 CRL Distribution Point，通知使用者去哪里下载对应的 CRL 以校验证书是否吊销。该吊销方式的优点是不需要频繁更新，但是不能及时吊销证书，因为 CRL 更新时间一般是几天，这期间可能已经造成了极大损失。 OCSP(Online Certificate Status Protocol), 证书状态在线查询协议，一个实时查询证书是否吊销的方式。请求者发送证书的信息并请求查询，服务器返回正常、吊销或未知中的任何一个状态。证书中一般也会包含一个 OCSP 的 URL 地址，要求查询服务器具有良好的性能。部分 CA 或大部分的自签 CA (根证书)都是未提供 CRL 或 OCSP 地址的，对于吊销证书会是一件非常麻烦的事情。 TLS/SSL握手过程 client_hello客户端发起请求，以明文传输请求信息，包含版本信息，加密套件候选列表，压缩算法候选列表，随机数，扩展字段等信息，相关信息如下： 支持的最高TSL协议版本version，从低到高依次 SSLv2 SSLv3 TLSv1 TLSv1.1 TLSv1.2，当前基本不再使用低于TLSv1的版本; 客户端支持的加密套件cipher suites列表， 每个加密套件对应前面 TLS 原理中的四个功能的组合：认证算法 Au (身份验证)、密钥交换算法 KeyExchange(密钥协商)、对称加密算法 Enc (信息加密)和信息摘要 Mac(完整性校验); 支持的压缩算法compression methods列表，用于后续的信息压缩传输; 随机数random_C，用于后续的密钥的生成; 扩展字段extensions，支持协议与算法的相关参数以及其它辅助信息等，常见的SNI就属于扩展字段，后续单独讨论该字段作用。 每一条消息都会包含有ContentType, Version, HandshakeType等信息。ContentType指示SSL通信处于哪个阶段，是握手(Handshake)，开始加密传输(ChangeCipherSpec)还是正常通信(Application)等，见下表 Hex Dec Type 0x14 20 ChangeCipherSpec 0x15 21 Alert 0x16 22 Handshake 0x17 23 Application Version是TLS的版本，见下表 Major Version Minor Version Version Type 3 0 SSLv3 3 1 TLS 1.0 3 2 TLS 1.1 3 3 TLS 1.2 Handshake Type是在handshanke阶段中的具体哪一步，见下表 Code Description 0 HelloRequest 1 ClientHello 2 ServerHello 11 Certificate 12 ServerKeyExchange 13 CertificateRequest 14 ServerHelloDone 15 CertificateVerify 16 ClientKeyExchange 20 Finished ClientHello附带的数据随机数据RN，会在生成session key时使用，Cipher suite列出了client支持的所有加密算法组合，可以看出每一组包含3种算法，一个是非对称算法，如RSA，一个是对称算法如DES，3DES，RC4等，一个是Hash算法，如MD5，SHA等，server会从这些算法组合中选取一组，作为本次SSL连接中使用。 server_hello+server_certificate+sever_hello_done server_hello, 服务端返回协商的信息结果，包括选择使用的协议版本version，选择的加密套件cipher suite，选择的压缩算法com pression method、随机数random_S等，其中随机数用于后续的密钥协商;这里多了个session id,如果SSL连接断开，再次连接时，可以使用该属性重新建立连接，在双方都有缓存的情况下可以省略握手的步骤。server端也会生成随机的RN，用于生成session key使用。server会从client发送的Cipher suite列表中跳出一个，这里挑选的是RSA + RC4 + MD5。这次server共发送的3个handshake 消息:Serverhello，Certificate和ServerHelloDone，共用一个ContentType:Handshake。 server_certificates, 服务器端配置对应的证书链，用于身份验证与密钥交换; server_hello_done，通知客户端 server_hello 信息发送结束; 证书校验客户端验证证书的合法性，如果验证通过才会进行后续通信，否则根据错误情况不同做出提示和操作，合法性验证包括如下： [证书链]的可信性trusted certificate path，方法如前文所述; 证书是否吊销revocation，有两类方式离线CRL与在线OCSP，不同的客户端行为会不同; 有效期expiry date，证书是否在有效时间范围; 域名domain，核查证书域名是否与当前的访问域名匹配，匹配规则后续分析; client_key_exchange+change_cipher_spec+encrypted_handshake_message client_key_exchange，合法性验证通过之后，客户端计算产生随机48字节的数字 Pre-master，padding并用证书公钥加密，发送给服务器; 此时客户端已经获取全部的计算协商密钥需要的信息：两个明文随机数 random_C 和 random_S 与自己计算产生的 Pre-master，计算得到协商密钥: master_key = Fuc(random_C, random_S, Pre-Master) change_cipher_spec，客户端通知服务器后续的通信都采用协商的通信密钥和加密算法进行加密通信; encrypted_handshake_message，结合之前所有通信参数的 hash 值与其它相关信息生成一段数据，采用协商密钥 session secret 与算法进行加密，然后发送给服务器用于数据与握手验证; client发送的加密数据，这个消息非常关键，一是能证明握手数据没有被篡改过，二也能证明自己确实是密钥的拥有者(这里是单边验证，只有server有certificate，server发送的Finished能证明自己含有private key，原理是一样的)。client将之前发送的所有握手消息存入handshake messages缓存，进行MD5和SHA-1两种hash运算，再与前面的master secret和一串常量”client finished”进行PRF伪随机运算得到12字节的verify data，还要经过改进的MD5计算得到加密信息。为什么能证明上述两点呢，前面说了只有密钥的拥有者才能解密得到pre-master key，master key，最后得到key block后，进行hash运算得到的结果才与发送方的一致。 change_cipher_spec+encrypted_handshake_message 服务器用私钥解密加密的Pre-master数据，基于之前交换的两个明文随机数random_C和random_S，计算得到协商密钥: master_key = Fuc(random_C, random_S, Pre-Master) 计算之前所有接收信息的hash值，然后解密客户端发送的encrypted_handshake_message，验证数据和密钥正确性; change_cipher_spec, 验证通过之后，服务器同样发送change_cipher_spec以告知客户端后续的通信都采用协商的密钥与算法进行加密通信; encrypted_handshake_message, 服务器也结合所有当前的通信参数信息生成一段数据并采用协商密钥session secret与算法加密并发送到客户端; 与client发送Finished计算方法一致。server发送的Finished里包含hash给client，client会进行校验，如果通过，说明握手过程中的数据没有被第三方篡改过，也说明server是之前交换证书的拥有者 。 握手结束客户端计算所有接收信息的hash值，并采用协商密钥解密encrypted_handshake_message，验证服务器发送的数据和密钥，验证通过则握手完成; 加密通信开始使用协商密钥与算法进行加密通信。 会话缓存过程为了加快建立握手的速度，减少协议带来的性能降低和资源消耗(具体分析在后文)，TLS 协议有两类会话缓存机制：会话标识session ID 与会话记录 session ticket。 session ID由服务器端支持，协议中的标准字段，因此基本所有服务器都支持，服务器端保存会话ID以及协商的通信信息，Nginx 中1M 内存约可以保存4000个session ID机器相关信息，占用服务器资源较多; session ticket需要服务器和客户端都支持，属于一个扩展字段，支持范围约60%(无可靠统计与来源)，将协商的通信信息加密之后发送给客户端保存，密钥只有服务器知道，占用服务器资源很少。 二者对比，主要是保存协商信息的位置与方式不同，类似与http中的session与cookie。 二者都存在的情况下，(nginx 实现)优先使用 session_ticket。 会话标识 session ID 如果客户端和服务器之间曾经建立了连接，服务器会在握手成功后返回session ID，并保存对应的通信参数在服务器中; 如果客户端再次需要和该服务器建立连接，则在client_hello 中session ID中携带记录的信息，发送给服务器; 服务器根据收到的session ID检索缓存记录，如果没有检索到货缓存过期，则按照正常的握手过程进行; 如果检索到对应的缓存记录，则返回change_cipher_spec与encrypted_handshake_message信息，两个信息作用类似，encrypted_handshake_message是到当前的通信参数与 master_secret的hash 值; 如果客户端能够验证通过服务器加密数据，则客户端同样发送change_cipher_spec与encrypted_handshake_message信息; 服务器验证数据通过，则握手建立成功，开始进行正常的加密数据通信。 会话记录 session ticket 如果客户端和服务器之间曾经建立了连接，服务器会在new_session_ticket数据中携带加密的session_ticket信息，客户端保存; 如果客户端再次需要和该服务器建立连接，则在client_hello中扩展字段session_ticket中携带加密信息，一起发送给服务器; 服务器解密sesssion_ticket数据，如果能够解密失败，则按照正常的握手过程进行; 如果解密成功，则返回change_cipher_spec与encrypted_handshake_message信息，两个信息作用与session ID中类似; 如果客户端能够验证通过服务器加密数据，则客户端同样发送change_cipher_spec与encrypted_handshake_message信息; 服务器验证数据通过，则握手建立成功，开始进行正常的加密数据通信。 密钥匙计算 客户端采用RSA或Diffie-Hellman等加密算法生成Pre-master; Pre-master结合random client和random server两个随机数通过PseudoRandomFunction(PRF)计算得到Master secret; Master secret结合random client和random server两个随机数通过迭代计算得到Key material; TLS/SSL协议详解之记录协议记录协议在客户机和服务器握手成功后使用，即客户机和服务器鉴别对方和确定安全信息交换使用的算法后，进入SSL记录协议，记录协议向SSL连接提供两个服务： 保密性：使用握手协议定义的秘密密钥实现 完整性：握手协议定义了MAC，用于保证消息完整性 SSL记录协议最后的步骤便是准备一个记录头，这个记录头包含以下的字段。 数据类型(Content type)，8位：用来处理这个分片的上层协议。 主要版本号(Major Version)，8位：所使用的SSI。协议的主要版本，对于SSI。v3协议来说，这个字段值为3。 次要版本号(Minor Version)，8位：表示使用的次要版本，对于SSLv3协议来说，这个字段值为0。 压缩后数据长度(Compressed length)，16位：这个明文分片的长度(假如此分片已经过压缩，则为压缩后的长度)。最大值为(214+2048)B。 TLS/SSL协议详解之警告协议定义SSL警告协议亦称SSL告警协议、SSL报警协议，是用来为对等实体传递SSL的相关警告。如果在通信过程中某一方发现任何异常，就需要给对方发送一条警示消息通告。 报文格式SSL报警协议报文由严重级别和警告代码两部分组成，如图所示。 SSL报警协议中严重级别分为Fatal和Waming为两种。其中，Fatal级报警即致命级报警，它要求通信双方都要采取紧急措施，并终止会话，如在数据传输过程中，若发现有错误的MAC，双方就需要立即中断会话，同时消除自己缓冲区相应的会话记录；而对Warning级报警即警告级报警的处理，通常是通信双方都只进行日志记录，它对通信过程不造成影响。 以下是一些警告信息： unexpected_message：接收了不合适的报文。 bad_record_mac：收到了不正确的MAC。 decompression_failure：解压缩函数收到不适当的输入。 illegal_parameter：握手报文中的一个字段超出范围或与其他字段不兼容。 certificate_revoked：证书已经被废弃。 bad_certificate：收到的证书是错误的。 certificate_expired：证书已经过期。 handshake_failer：握手过程失败。 ———– The End ———–]]></content>
      <categories>
        <category>Protocol</category>
      </categories>
      <tags>
        <tag>protocol</tag>
        <tag>ssl</tag>
        <tag>wireshark</tag>
      </tags>
  </entry>
</search>
